# ! [doc = "Peripheral access API for MCXC444 microcontrollers (generated using svd2rust v0.33.4 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.4/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 2 ; # [allow (unused_imports)] use generic :: * ; # [doc = r"Common register and bit access and modify traits"] pub mod generic ; # [cfg (feature = "rt")] extern "C" { fn DMA0 () ; fn DMA1 () ; fn DMA2 () ; fn DMA3 () ; fn FTFA () ; fn PMC () ; fn LLWU () ; fn I2C0 () ; fn I2C1 () ; fn SPI0 () ; fn SPI1 () ; fn LPUART0 () ; fn LPUART1 () ; fn UART2_FLEXIO () ; fn ADC0 () ; fn CMP0 () ; fn TPM0 () ; fn TPM1 () ; fn TPM2 () ; fn RTC () ; fn RTC_Seconds () ; fn PIT () ; fn I2S0 () ; fn USB0 () ; fn DAC0 () ; fn LPTMR0 () ; fn LCD () ; fn PORTA () ; fn PORTC_PORTD () ; } # [doc (hidden)] # [repr (C)] pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , } # [cfg (feature = "rt")] # [doc (hidden)] # [link_section = ".vector_table.interrupts"] # [no_mangle] pub static __INTERRUPTS : [Vector ; 32] = [Vector { _handler : DMA0 } , Vector { _handler : DMA1 } , Vector { _handler : DMA2 } , Vector { _handler : DMA3 } , Vector { _reserved : 0 } , Vector { _handler : FTFA } , Vector { _handler : PMC } , Vector { _handler : LLWU } , Vector { _handler : I2C0 } , Vector { _handler : I2C1 } , Vector { _handler : SPI0 } , Vector { _handler : SPI1 } , Vector { _handler : LPUART0 } , Vector { _handler : LPUART1 } , Vector { _handler : UART2_FLEXIO } , Vector { _handler : ADC0 } , Vector { _handler : CMP0 } , Vector { _handler : TPM0 } , Vector { _handler : TPM1 } , Vector { _handler : TPM2 } , Vector { _handler : RTC } , Vector { _handler : RTC_Seconds } , Vector { _handler : PIT } , Vector { _handler : I2S0 } , Vector { _handler : USB0 } , Vector { _handler : DAC0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : LPTMR0 } , Vector { _handler : LCD } , Vector { _handler : PORTA } , Vector { _handler : PORTC_PORTD } ,] ; # [doc = r"Enumeration of all the interrupts."] # [derive (Copy , Clone , Debug , PartialEq , Eq)] # [repr (u16)] pub enum Interrupt { # [doc = "0 - DMA0"] DMA0 = 0 , # [doc = "1 - DMA1"] DMA1 = 1 , # [doc = "2 - DMA2"] DMA2 = 2 , # [doc = "3 - DMA3"] DMA3 = 3 , # [doc = "5 - FTFA"] FTFA = 5 , # [doc = "6 - PMC"] PMC = 6 , # [doc = "7 - LLWU"] LLWU = 7 , # [doc = "8 - I2C0"] I2C0 = 8 , # [doc = "9 - I2C1"] I2C1 = 9 , # [doc = "10 - SPI0"] SPI0 = 10 , # [doc = "11 - SPI1"] SPI1 = 11 , # [doc = "12 - LPUART0"] LPUART0 = 12 , # [doc = "13 - LPUART1"] LPUART1 = 13 , # [doc = "14 - UART2_FLEXIO"] UART2_FLEXIO = 14 , # [doc = "15 - ADC0"] ADC0 = 15 , # [doc = "16 - CMP0"] CMP0 = 16 , # [doc = "17 - TPM0"] TPM0 = 17 , # [doc = "18 - TPM1"] TPM1 = 18 , # [doc = "19 - TPM2"] TPM2 = 19 , # [doc = "20 - RTC"] RTC = 20 , # [doc = "21 - RTC_Seconds"] RTC_Seconds = 21 , # [doc = "22 - PIT"] PIT = 22 , # [doc = "23 - I2S0"] I2S0 = 23 , # [doc = "24 - USB0"] USB0 = 24 , # [doc = "25 - DAC0"] DAC0 = 25 , # [doc = "28 - LPTMR0"] LPTMR0 = 28 , # [doc = "29 - LCD"] LCD = 29 , # [doc = "30 - PORTA"] PORTA = 30 , # [doc = "31 - PORTC_PORTD"] PORTC_PORTD = 31 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt { # [inline (always)] fn number (self) -> u16 { self as u16 } } # [doc = "Flash configuration field"] pub struct FtfaFlashConfig { _marker : PhantomData < * const () > } unsafe impl Send for FtfaFlashConfig { } impl FtfaFlashConfig { # [doc = r"Pointer to the register block"] pub const PTR : * const ftfa_flash_config :: RegisterBlock = 0x0400 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const ftfa_flash_config :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for FtfaFlashConfig { type Target = ftfa_flash_config :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FtfaFlashConfig { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FtfaFlashConfig") . finish () } } # [doc = "Flash configuration field"] pub mod ftfa_flash_config ; # [doc = "DMA Controller"] pub struct Dma { _marker : PhantomData < * const () > } unsafe impl Send for Dma { } impl Dma { # [doc = r"Pointer to the register block"] pub const PTR : * const dma :: RegisterBlock = 0x4000_8000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const dma :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Dma { type Target = dma :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Dma { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma") . finish () } } # [doc = "DMA Controller"] pub mod dma ; # [doc = "Flash Memory Interface"] pub struct Ftfa { _marker : PhantomData < * const () > } unsafe impl Send for Ftfa { } impl Ftfa { # [doc = r"Pointer to the register block"] pub const PTR : * const ftfa :: RegisterBlock = 0x4002_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const ftfa :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Ftfa { type Target = ftfa :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Ftfa { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ftfa") . finish () } } # [doc = "Flash Memory Interface"] pub mod ftfa ; # [doc = "DMA channel multiplexor"] pub struct Dmamux0 { _marker : PhantomData < * const () > } unsafe impl Send for Dmamux0 { } impl Dmamux0 { # [doc = r"Pointer to the register block"] pub const PTR : * const dmamux0 :: RegisterBlock = 0x4002_1000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const dmamux0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Dmamux0 { type Target = dmamux0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Dmamux0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dmamux0") . finish () } } # [doc = "DMA channel multiplexor"] pub mod dmamux0 ; # [doc = "Inter-IC Sound / Synchronous Audio Interface"] pub struct I2s0 { _marker : PhantomData < * const () > } unsafe impl Send for I2s0 { } impl I2s0 { # [doc = r"Pointer to the register block"] pub const PTR : * const i2s0 :: RegisterBlock = 0x4002_f000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const i2s0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for I2s0 { type Target = i2s0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2s0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2s0") . finish () } } # [doc = "Inter-IC Sound / Synchronous Audio Interface"] pub mod i2s0 ; # [doc = "Periodic Interrupt Timer"] pub struct Pit { _marker : PhantomData < * const () > } unsafe impl Send for Pit { } impl Pit { # [doc = r"Pointer to the register block"] pub const PTR : * const pit :: RegisterBlock = 0x4003_7000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const pit :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Pit { type Target = pit :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Pit { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pit") . finish () } } # [doc = "Periodic Interrupt Timer"] pub mod pit ; # [doc = "Timer/PWM Module"] pub struct Tpm0 { _marker : PhantomData < * const () > } unsafe impl Send for Tpm0 { } impl Tpm0 { # [doc = r"Pointer to the register block"] pub const PTR : * const tpm0 :: RegisterBlock = 0x4003_8000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const tpm0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Tpm0 { type Target = tpm0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Tpm0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tpm0") . finish () } } # [doc = "Timer/PWM Module"] pub mod tpm0 ; # [doc = "Timer/PWM Module"] pub struct Tpm1 { _marker : PhantomData < * const () > } unsafe impl Send for Tpm1 { } impl Tpm1 { # [doc = r"Pointer to the register block"] pub const PTR : * const tpm1 :: RegisterBlock = 0x4003_9000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const tpm1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Tpm1 { type Target = tpm1 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Tpm1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tpm1") . finish () } } # [doc = "Timer/PWM Module"] pub mod tpm1 ; # [doc = "Timer/PWM Module"] pub struct Tpm2 { _marker : PhantomData < * const () > } unsafe impl Send for Tpm2 { } impl Tpm2 { # [doc = r"Pointer to the register block"] pub const PTR : * const tpm2 :: RegisterBlock = 0x4003_a000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const tpm2 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Tpm2 { type Target = tpm2 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Tpm2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tpm2") . finish () } } # [doc = "Timer/PWM Module"] pub mod tpm2 ; # [doc = "Analog-to-Digital Converter"] pub struct Adc0 { _marker : PhantomData < * const () > } unsafe impl Send for Adc0 { } impl Adc0 { # [doc = r"Pointer to the register block"] pub const PTR : * const adc0 :: RegisterBlock = 0x4003_b000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const adc0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Adc0 { type Target = adc0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Adc0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc0") . finish () } } # [doc = "Analog-to-Digital Converter"] pub mod adc0 ; # [doc = "Secure Real Time Clock"] pub struct Rtc { _marker : PhantomData < * const () > } unsafe impl Send for Rtc { } impl Rtc { # [doc = r"Pointer to the register block"] pub const PTR : * const rtc :: RegisterBlock = 0x4003_d000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const rtc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Rtc { type Target = rtc :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Rtc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rtc") . finish () } } # [doc = "Secure Real Time Clock"] pub mod rtc ; # [doc = "12-Bit Digital-to-Analog Converter"] pub struct Dac0 { _marker : PhantomData < * const () > } unsafe impl Send for Dac0 { } impl Dac0 { # [doc = r"Pointer to the register block"] pub const PTR : * const dac0 :: RegisterBlock = 0x4003_f000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const dac0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Dac0 { type Target = dac0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Dac0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dac0") . finish () } } # [doc = "12-Bit Digital-to-Analog Converter"] pub mod dac0 ; # [doc = "Low Power Timer"] pub struct Lptmr0 { _marker : PhantomData < * const () > } unsafe impl Send for Lptmr0 { } impl Lptmr0 { # [doc = r"Pointer to the register block"] pub const PTR : * const lptmr0 :: RegisterBlock = 0x4004_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const lptmr0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Lptmr0 { type Target = lptmr0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Lptmr0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lptmr0") . finish () } } # [doc = "Low Power Timer"] pub mod lptmr0 ; # [doc = "System register file"] pub struct Rfsys { _marker : PhantomData < * const () > } unsafe impl Send for Rfsys { } impl Rfsys { # [doc = r"Pointer to the register block"] pub const PTR : * const rfsys :: RegisterBlock = 0x4004_1000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const rfsys :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Rfsys { type Target = rfsys :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Rfsys { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rfsys") . finish () } } # [doc = "System register file"] pub mod rfsys ; # [doc = "System Integration Module"] pub struct Sim { _marker : PhantomData < * const () > } unsafe impl Send for Sim { } impl Sim { # [doc = r"Pointer to the register block"] pub const PTR : * const sim :: RegisterBlock = 0x4004_7000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const sim :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Sim { type Target = sim :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Sim { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sim") . finish () } } # [doc = "System Integration Module"] pub mod sim ; # [doc = "Pin Control and Interrupts"] pub struct Porta { _marker : PhantomData < * const () > } unsafe impl Send for Porta { } impl Porta { # [doc = r"Pointer to the register block"] pub const PTR : * const porta :: RegisterBlock = 0x4004_9000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const porta :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Porta { type Target = porta :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Porta { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Porta") . finish () } } # [doc = "Pin Control and Interrupts"] pub mod porta ; # [doc = "Pin Control and Interrupts"] pub struct Portb { _marker : PhantomData < * const () > } unsafe impl Send for Portb { } impl Portb { # [doc = r"Pointer to the register block"] pub const PTR : * const portb :: RegisterBlock = 0x4004_a000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const portb :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Portb { type Target = portb :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Portb { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Portb") . finish () } } # [doc = "Pin Control and Interrupts"] pub mod portb ; # [doc = "Pin Control and Interrupts"] pub struct Portc { _marker : PhantomData < * const () > } unsafe impl Send for Portc { } impl Portc { # [doc = r"Pointer to the register block"] pub const PTR : * const portc :: RegisterBlock = 0x4004_b000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const portc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Portc { type Target = portc :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Portc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Portc") . finish () } } # [doc = "Pin Control and Interrupts"] pub mod portc ; # [doc = "Pin Control and Interrupts"] pub struct Portd { _marker : PhantomData < * const () > } unsafe impl Send for Portd { } impl Portd { # [doc = r"Pointer to the register block"] pub const PTR : * const portd :: RegisterBlock = 0x4004_c000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const portd :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Portd { type Target = portd :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Portd { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Portd") . finish () } } # [doc = "Pin Control and Interrupts"] pub mod portd ; # [doc = "Pin Control and Interrupts"] pub struct Porte { _marker : PhantomData < * const () > } unsafe impl Send for Porte { } impl Porte { # [doc = r"Pointer to the register block"] pub const PTR : * const porte :: RegisterBlock = 0x4004_d000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const porte :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Porte { type Target = porte :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Porte { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Porte") . finish () } } # [doc = "Pin Control and Interrupts"] pub mod porte ; # [doc = "Segment Liquid Crystal Display"] pub struct Lcd { _marker : PhantomData < * const () > } unsafe impl Send for Lcd { } impl Lcd { # [doc = r"Pointer to the register block"] pub const PTR : * const lcd :: RegisterBlock = 0x4005_3000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const lcd :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Lcd { type Target = lcd :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Lcd { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lcd") . finish () } } # [doc = "Segment Liquid Crystal Display"] pub mod lcd ; # [doc = "Universal Asynchronous Receiver/Transmitter"] pub struct Lpuart0 { _marker : PhantomData < * const () > } unsafe impl Send for Lpuart0 { } impl Lpuart0 { # [doc = r"Pointer to the register block"] pub const PTR : * const lpuart0 :: RegisterBlock = 0x4005_4000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const lpuart0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Lpuart0 { type Target = lpuart0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Lpuart0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lpuart0") . finish () } } # [doc = "Universal Asynchronous Receiver/Transmitter"] pub mod lpuart0 ; # [doc = "Universal Asynchronous Receiver/Transmitter"] pub struct Lpuart1 { _marker : PhantomData < * const () > } unsafe impl Send for Lpuart1 { } impl Lpuart1 { # [doc = r"Pointer to the register block"] pub const PTR : * const lpuart1 :: RegisterBlock = 0x4005_5000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const lpuart1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Lpuart1 { type Target = lpuart1 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Lpuart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lpuart1") . finish () } } # [doc = "Universal Asynchronous Receiver/Transmitter"] pub mod lpuart1 ; # [doc = "Flexible I/O - universal I/O module for communication (UART, SPI, I2C, I2S) and PWM purposes."] pub struct Flexio { _marker : PhantomData < * const () > } unsafe impl Send for Flexio { } impl Flexio { # [doc = r"Pointer to the register block"] pub const PTR : * const flexio :: RegisterBlock = 0x4005_f000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const flexio :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Flexio { type Target = flexio :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Flexio { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Flexio") . finish () } } # [doc = "Flexible I/O - universal I/O module for communication (UART, SPI, I2C, I2S) and PWM purposes."] pub mod flexio ; # [doc = "Multipurpose Clock Generator Lite"] pub struct Mcg { _marker : PhantomData < * const () > } unsafe impl Send for Mcg { } impl Mcg { # [doc = r"Pointer to the register block"] pub const PTR : * const mcg :: RegisterBlock = 0x4006_4000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const mcg :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Mcg { type Target = mcg :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Mcg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Mcg") . finish () } } # [doc = "Multipurpose Clock Generator Lite"] pub mod mcg ; # [doc = "Oscillator"] pub struct Osc0 { _marker : PhantomData < * const () > } unsafe impl Send for Osc0 { } impl Osc0 { # [doc = r"Pointer to the register block"] pub const PTR : * const osc0 :: RegisterBlock = 0x4006_5000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const osc0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Osc0 { type Target = osc0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Osc0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Osc0") . finish () } } # [doc = "Oscillator"] pub mod osc0 ; # [doc = "Inter-Integrated Circuit"] pub struct I2c0 { _marker : PhantomData < * const () > } unsafe impl Send for I2c0 { } impl I2c0 { # [doc = r"Pointer to the register block"] pub const PTR : * const i2c0 :: RegisterBlock = 0x4006_6000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const i2c0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for I2c0 { type Target = i2c0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2c0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c0") . finish () } } # [doc = "Inter-Integrated Circuit"] pub mod i2c0 ; # [doc = "Inter-Integrated Circuit"] pub struct I2c1 { _marker : PhantomData < * const () > } unsafe impl Send for I2c1 { } impl I2c1 { # [doc = r"Pointer to the register block"] pub const PTR : * const i2c1 :: RegisterBlock = 0x4006_7000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const i2c1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for I2c1 { type Target = i2c1 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2c1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c1") . finish () } } # [doc = "Inter-Integrated Circuit"] pub mod i2c1 ; # [doc = "Serial Communication Interface"] pub struct Uart2 { _marker : PhantomData < * const () > } unsafe impl Send for Uart2 { } impl Uart2 { # [doc = r"Pointer to the register block"] pub const PTR : * const uart2 :: RegisterBlock = 0x4006_c000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const uart2 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Uart2 { type Target = uart2 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Uart2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart2") . finish () } } # [doc = "Serial Communication Interface"] pub mod uart2 ; # [doc = "Universal Serial Bus, OTG Capable Controller"] pub struct Usb0 { _marker : PhantomData < * const () > } unsafe impl Send for Usb0 { } impl Usb0 { # [doc = r"Pointer to the register block"] pub const PTR : * const usb0 :: RegisterBlock = 0x4007_2000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const usb0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Usb0 { type Target = usb0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Usb0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usb0") . finish () } } # [doc = "Universal Serial Bus, OTG Capable Controller"] pub mod usb0 ; # [doc = "High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)"] pub struct Cmp0 { _marker : PhantomData < * const () > } unsafe impl Send for Cmp0 { } impl Cmp0 { # [doc = r"Pointer to the register block"] pub const PTR : * const cmp0 :: RegisterBlock = 0x4007_3000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const cmp0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Cmp0 { type Target = cmp0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Cmp0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cmp0") . finish () } } # [doc = "High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)"] pub mod cmp0 ; # [doc = "Voltage Reference"] pub struct Vref { _marker : PhantomData < * const () > } unsafe impl Send for Vref { } impl Vref { # [doc = r"Pointer to the register block"] pub const PTR : * const vref :: RegisterBlock = 0x4007_4000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const vref :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Vref { type Target = vref :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Vref { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Vref") . finish () } } # [doc = "Voltage Reference"] pub mod vref ; # [doc = "Serial Peripheral Interface"] pub struct Spi0 { _marker : PhantomData < * const () > } unsafe impl Send for Spi0 { } impl Spi0 { # [doc = r"Pointer to the register block"] pub const PTR : * const spi0 :: RegisterBlock = 0x4007_6000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const spi0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Spi0 { type Target = spi0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Spi0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi0") . finish () } } # [doc = "Serial Peripheral Interface"] pub mod spi0 ; # [doc = "Serial Peripheral Interface"] pub struct Spi1 { _marker : PhantomData < * const () > } unsafe impl Send for Spi1 { } impl Spi1 { # [doc = r"Pointer to the register block"] pub const PTR : * const spi1 :: RegisterBlock = 0x4007_7000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const spi1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Spi1 { type Target = spi1 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Spi1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi1") . finish () } } # [doc = "Serial Peripheral Interface"] pub mod spi1 ; # [doc = "Low leakage wakeup unit"] pub struct Llwu { _marker : PhantomData < * const () > } unsafe impl Send for Llwu { } impl Llwu { # [doc = r"Pointer to the register block"] pub const PTR : * const llwu :: RegisterBlock = 0x4007_c000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const llwu :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Llwu { type Target = llwu :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Llwu { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Llwu") . finish () } } # [doc = "Low leakage wakeup unit"] pub mod llwu ; # [doc = "Power Management Controller"] pub struct Pmc { _marker : PhantomData < * const () > } unsafe impl Send for Pmc { } impl Pmc { # [doc = r"Pointer to the register block"] pub const PTR : * const pmc :: RegisterBlock = 0x4007_d000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const pmc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Pmc { type Target = pmc :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Pmc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pmc") . finish () } } # [doc = "Power Management Controller"] pub mod pmc ; # [doc = "System Mode Controller"] pub struct Smc { _marker : PhantomData < * const () > } unsafe impl Send for Smc { } impl Smc { # [doc = r"Pointer to the register block"] pub const PTR : * const smc :: RegisterBlock = 0x4007_e000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const smc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Smc { type Target = smc :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Smc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Smc") . finish () } } # [doc = "System Mode Controller"] pub mod smc ; # [doc = "Reset Control Module"] pub struct Rcm { _marker : PhantomData < * const () > } unsafe impl Send for Rcm { } impl Rcm { # [doc = r"Pointer to the register block"] pub const PTR : * const rcm :: RegisterBlock = 0x4007_f000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const rcm :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Rcm { type Target = rcm :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Rcm { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rcm") . finish () } } # [doc = "Reset Control Module"] pub mod rcm ; # [doc = "General Purpose Input/Output"] pub struct Gpioa { _marker : PhantomData < * const () > } unsafe impl Send for Gpioa { } impl Gpioa { # [doc = r"Pointer to the register block"] pub const PTR : * const gpioa :: RegisterBlock = 0x400f_f000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const gpioa :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Gpioa { type Target = gpioa :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Gpioa { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioa") . finish () } } # [doc = "General Purpose Input/Output"] pub mod gpioa ; # [doc = "General Purpose Input/Output"] pub struct Gpiob { _marker : PhantomData < * const () > } unsafe impl Send for Gpiob { } impl Gpiob { # [doc = r"Pointer to the register block"] pub const PTR : * const gpiob :: RegisterBlock = 0x400f_f040 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const gpiob :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Gpiob { type Target = gpiob :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Gpiob { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiob") . finish () } } # [doc = "General Purpose Input/Output"] pub mod gpiob ; # [doc = "General Purpose Input/Output"] pub struct Gpioc { _marker : PhantomData < * const () > } unsafe impl Send for Gpioc { } impl Gpioc { # [doc = r"Pointer to the register block"] pub const PTR : * const gpioc :: RegisterBlock = 0x400f_f080 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const gpioc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Gpioc { type Target = gpioc :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Gpioc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioc") . finish () } } # [doc = "General Purpose Input/Output"] pub mod gpioc ; # [doc = "General Purpose Input/Output"] pub struct Gpiod { _marker : PhantomData < * const () > } unsafe impl Send for Gpiod { } impl Gpiod { # [doc = r"Pointer to the register block"] pub const PTR : * const gpiod :: RegisterBlock = 0x400f_f0c0 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const gpiod :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Gpiod { type Target = gpiod :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Gpiod { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiod") . finish () } } # [doc = "General Purpose Input/Output"] pub mod gpiod ; # [doc = "General Purpose Input/Output"] pub struct Gpioe { _marker : PhantomData < * const () > } unsafe impl Send for Gpioe { } impl Gpioe { # [doc = r"Pointer to the register block"] pub const PTR : * const gpioe :: RegisterBlock = 0x400f_f100 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const gpioe :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Gpioe { type Target = gpioe :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Gpioe { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioe") . finish () } } # [doc = "General Purpose Input/Output"] pub mod gpioe ; # [doc = "System Control Block"] pub struct SystemControl { _marker : PhantomData < * const () > } unsafe impl Send for SystemControl { } impl SystemControl { # [doc = r"Pointer to the register block"] pub const PTR : * const system_control :: RegisterBlock = 0xe000_e000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const system_control :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SystemControl { type Target = system_control :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SystemControl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SystemControl") . finish () } } # [doc = "System Control Block"] pub mod system_control ; # [doc = "System timer"] pub struct SysTick { _marker : PhantomData < * const () > } unsafe impl Send for SysTick { } impl SysTick { # [doc = r"Pointer to the register block"] pub const PTR : * const sys_tick :: RegisterBlock = 0xe000_e010 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const sys_tick :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SysTick { type Target = sys_tick :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SysTick { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SysTick") . finish () } } # [doc = "System timer"] pub mod sys_tick ; # [doc = "Micro Trace Buffer"] pub struct Mtb { _marker : PhantomData < * const () > } unsafe impl Send for Mtb { } impl Mtb { # [doc = r"Pointer to the register block"] pub const PTR : * const mtb :: RegisterBlock = 0xf000_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const mtb :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Mtb { type Target = mtb :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Mtb { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Mtb") . finish () } } # [doc = "Micro Trace Buffer"] pub mod mtb ; # [doc = "MTB data watchpoint and trace"] pub struct Mtbdwt { _marker : PhantomData < * const () > } unsafe impl Send for Mtbdwt { } impl Mtbdwt { # [doc = r"Pointer to the register block"] pub const PTR : * const mtbdwt :: RegisterBlock = 0xf000_1000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const mtbdwt :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Mtbdwt { type Target = mtbdwt :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Mtbdwt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Mtbdwt") . finish () } } # [doc = "MTB data watchpoint and trace"] pub mod mtbdwt ; # [doc = "System ROM"] pub struct Rom { _marker : PhantomData < * const () > } unsafe impl Send for Rom { } impl Rom { # [doc = r"Pointer to the register block"] pub const PTR : * const rom :: RegisterBlock = 0xf000_2000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const rom :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Rom { type Target = rom :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Rom { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rom") . finish () } } # [doc = "System ROM"] pub mod rom ; # [doc = "Core Platform Miscellaneous Control Module"] pub struct Mcm { _marker : PhantomData < * const () > } unsafe impl Send for Mcm { } impl Mcm { # [doc = r"Pointer to the register block"] pub const PTR : * const mcm :: RegisterBlock = 0xf000_3000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const mcm :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Mcm { type Target = mcm :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Mcm { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Mcm") . finish () } } # [doc = "Core Platform Miscellaneous Control Module"] pub mod mcm ; # [doc = "General Purpose Input/Output"] pub struct Fgpioa { _marker : PhantomData < * const () > } unsafe impl Send for Fgpioa { } impl Fgpioa { # [doc = r"Pointer to the register block"] pub const PTR : * const fgpioa :: RegisterBlock = 0xf800_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const fgpioa :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Fgpioa { type Target = fgpioa :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Fgpioa { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fgpioa") . finish () } } # [doc = "General Purpose Input/Output"] pub mod fgpioa ; # [doc = "General Purpose Input/Output"] pub struct Fgpiob { _marker : PhantomData < * const () > } unsafe impl Send for Fgpiob { } impl Fgpiob { # [doc = r"Pointer to the register block"] pub const PTR : * const fgpiob :: RegisterBlock = 0xf800_0040 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const fgpiob :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Fgpiob { type Target = fgpiob :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Fgpiob { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fgpiob") . finish () } } # [doc = "General Purpose Input/Output"] pub mod fgpiob ; # [doc = "General Purpose Input/Output"] pub struct Fgpioc { _marker : PhantomData < * const () > } unsafe impl Send for Fgpioc { } impl Fgpioc { # [doc = r"Pointer to the register block"] pub const PTR : * const fgpioc :: RegisterBlock = 0xf800_0080 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const fgpioc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Fgpioc { type Target = fgpioc :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Fgpioc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fgpioc") . finish () } } # [doc = "General Purpose Input/Output"] pub mod fgpioc ; # [doc = "General Purpose Input/Output"] pub struct Fgpiod { _marker : PhantomData < * const () > } unsafe impl Send for Fgpiod { } impl Fgpiod { # [doc = r"Pointer to the register block"] pub const PTR : * const fgpiod :: RegisterBlock = 0xf800_00c0 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const fgpiod :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Fgpiod { type Target = fgpiod :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Fgpiod { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fgpiod") . finish () } } # [doc = "General Purpose Input/Output"] pub mod fgpiod ; # [doc = "General Purpose Input/Output"] pub struct Fgpioe { _marker : PhantomData < * const () > } unsafe impl Send for Fgpioe { } impl Fgpioe { # [doc = r"Pointer to the register block"] pub const PTR : * const fgpioe :: RegisterBlock = 0xf800_0100 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const fgpioe :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Fgpioe { type Target = fgpioe :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Fgpioe { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fgpioe") . finish () } } # [doc = "General Purpose Input/Output"] pub mod fgpioe ; # [no_mangle] static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."] # [allow (non_snake_case)] pub struct Peripherals { # [doc = "FTFA_FlashConfig"] pub ftfa_flash_config : FtfaFlashConfig , # [doc = "DMA"] pub dma : Dma , # [doc = "FTFA"] pub ftfa : Ftfa , # [doc = "DMAMUX0"] pub dmamux0 : Dmamux0 , # [doc = "I2S0"] pub i2s0 : I2s0 , # [doc = "PIT"] pub pit : Pit , # [doc = "TPM0"] pub tpm0 : Tpm0 , # [doc = "TPM1"] pub tpm1 : Tpm1 , # [doc = "TPM2"] pub tpm2 : Tpm2 , # [doc = "ADC0"] pub adc0 : Adc0 , # [doc = "RTC"] pub rtc : Rtc , # [doc = "DAC0"] pub dac0 : Dac0 , # [doc = "LPTMR0"] pub lptmr0 : Lptmr0 , # [doc = "RFSYS"] pub rfsys : Rfsys , # [doc = "SIM"] pub sim : Sim , # [doc = "PORTA"] pub porta : Porta , # [doc = "PORTB"] pub portb : Portb , # [doc = "PORTC"] pub portc : Portc , # [doc = "PORTD"] pub portd : Portd , # [doc = "PORTE"] pub porte : Porte , # [doc = "LCD"] pub lcd : Lcd , # [doc = "LPUART0"] pub lpuart0 : Lpuart0 , # [doc = "LPUART1"] pub lpuart1 : Lpuart1 , # [doc = "FLEXIO"] pub flexio : Flexio , # [doc = "MCG"] pub mcg : Mcg , # [doc = "OSC0"] pub osc0 : Osc0 , # [doc = "I2C0"] pub i2c0 : I2c0 , # [doc = "I2C1"] pub i2c1 : I2c1 , # [doc = "UART2"] pub uart2 : Uart2 , # [doc = "USB0"] pub usb0 : Usb0 , # [doc = "CMP0"] pub cmp0 : Cmp0 , # [doc = "VREF"] pub vref : Vref , # [doc = "SPI0"] pub spi0 : Spi0 , # [doc = "SPI1"] pub spi1 : Spi1 , # [doc = "LLWU"] pub llwu : Llwu , # [doc = "PMC"] pub pmc : Pmc , # [doc = "SMC"] pub smc : Smc , # [doc = "RCM"] pub rcm : Rcm , # [doc = "GPIOA"] pub gpioa : Gpioa , # [doc = "GPIOB"] pub gpiob : Gpiob , # [doc = "GPIOC"] pub gpioc : Gpioc , # [doc = "GPIOD"] pub gpiod : Gpiod , # [doc = "GPIOE"] pub gpioe : Gpioe , # [doc = "SystemControl"] pub system_control : SystemControl , # [doc = "SysTick"] pub sys_tick : SysTick , # [doc = "MTB"] pub mtb : Mtb , # [doc = "MTBDWT"] pub mtbdwt : Mtbdwt , # [doc = "ROM"] pub rom : Rom , # [doc = "MCM"] pub mcm : Mcm , # [doc = "FGPIOA"] pub fgpioa : Fgpioa , # [doc = "FGPIOB"] pub fgpiob : Fgpiob , # [doc = "FGPIOC"] pub fgpioc : Fgpioc , # [doc = "FGPIOD"] pub fgpiod : Fgpiod , # [doc = "FGPIOE"] pub fgpioe : Fgpioe , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."] # [cfg (feature = "critical-section")] # [inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Each of the returned peripherals must be used at most once."] # [inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { ftfa_flash_config : FtfaFlashConfig :: steal () , dma : Dma :: steal () , ftfa : Ftfa :: steal () , dmamux0 : Dmamux0 :: steal () , i2s0 : I2s0 :: steal () , pit : Pit :: steal () , tpm0 : Tpm0 :: steal () , tpm1 : Tpm1 :: steal () , tpm2 : Tpm2 :: steal () , adc0 : Adc0 :: steal () , rtc : Rtc :: steal () , dac0 : Dac0 :: steal () , lptmr0 : Lptmr0 :: steal () , rfsys : Rfsys :: steal () , sim : Sim :: steal () , porta : Porta :: steal () , portb : Portb :: steal () , portc : Portc :: steal () , portd : Portd :: steal () , porte : Porte :: steal () , lcd : Lcd :: steal () , lpuart0 : Lpuart0 :: steal () , lpuart1 : Lpuart1 :: steal () , flexio : Flexio :: steal () , mcg : Mcg :: steal () , osc0 : Osc0 :: steal () , i2c0 : I2c0 :: steal () , i2c1 : I2c1 :: steal () , uart2 : Uart2 :: steal () , usb0 : Usb0 :: steal () , cmp0 : Cmp0 :: steal () , vref : Vref :: steal () , spi0 : Spi0 :: steal () , spi1 : Spi1 :: steal () , llwu : Llwu :: steal () , pmc : Pmc :: steal () , smc : Smc :: steal () , rcm : Rcm :: steal () , gpioa : Gpioa :: steal () , gpiob : Gpiob :: steal () , gpioc : Gpioc :: steal () , gpiod : Gpiod :: steal () , gpioe : Gpioe :: steal () , system_control : SystemControl :: steal () , sys_tick : SysTick :: steal () , mtb : Mtb :: steal () , mtbdwt : Mtbdwt :: steal () , rom : Rom :: steal () , mcm : Mcm :: steal () , fgpioa : Fgpioa :: steal () , fgpiob : Fgpiob :: steal () , fgpioc : Fgpioc :: steal () , fgpiod : Fgpiod :: steal () , fgpioe : Fgpioe :: steal () , } } }