#[doc = "Register `C1` reader"]
pub type R = crate::R<C1Spec>;
#[doc = "Register `C1` writer"]
pub type W = crate::W<C1Spec>;
#[doc = "DAC Buffer Enable\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Dacbfen {
    #[doc = "0: Buffer read pointer is disabled. The converted data is always the first word of the buffer."]
    B0 = 0,
    #[doc = "1: Buffer read pointer is enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer."]
    B1 = 1,
}
impl From<Dacbfen> for bool {
    #[inline(always)]
    fn from(variant: Dacbfen) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `DACBFEN` reader - DAC Buffer Enable"]
pub type DacbfenR = crate::BitReader<Dacbfen>;
impl DacbfenR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Dacbfen {
        match self.bits {
            false => Dacbfen::B0,
            true => Dacbfen::B1,
        }
    }
    #[doc = "Buffer read pointer is disabled. The converted data is always the first word of the buffer."]
    #[inline(always)]
    pub fn is_b0(&self) -> bool {
        *self == Dacbfen::B0
    }
    #[doc = "Buffer read pointer is enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer."]
    #[inline(always)]
    pub fn is_b1(&self) -> bool {
        *self == Dacbfen::B1
    }
}
#[doc = "Field `DACBFEN` writer - DAC Buffer Enable"]
pub type DacbfenW<'a, REG> = crate::BitWriter<'a, REG, Dacbfen>;
impl<'a, REG> DacbfenW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Buffer read pointer is disabled. The converted data is always the first word of the buffer."]
    #[inline(always)]
    pub fn b0(self) -> &'a mut crate::W<REG> {
        self.variant(Dacbfen::B0)
    }
    #[doc = "Buffer read pointer is enabled. The converted data is the word that the read pointer points to. It means converted data can be from any word of the buffer."]
    #[inline(always)]
    pub fn b1(self) -> &'a mut crate::W<REG> {
        self.variant(Dacbfen::B1)
    }
}
#[doc = "DAC Buffer Work Mode Select\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum Dacbfmd {
    #[doc = "0: Normal mode"]
    B00 = 0,
    #[doc = "2: One-Time Scan mode"]
    B10 = 2,
    #[doc = "3: FIFO mode"]
    B11 = 3,
}
impl From<Dacbfmd> for u8 {
    #[inline(always)]
    fn from(variant: Dacbfmd) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for Dacbfmd {
    type Ux = u8;
}
impl crate::IsEnum for Dacbfmd {}
#[doc = "Field `DACBFMD` reader - DAC Buffer Work Mode Select"]
pub type DacbfmdR = crate::FieldReader<Dacbfmd>;
impl DacbfmdR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Option<Dacbfmd> {
        match self.bits {
            0 => Some(Dacbfmd::B00),
            2 => Some(Dacbfmd::B10),
            3 => Some(Dacbfmd::B11),
            _ => None,
        }
    }
    #[doc = "Normal mode"]
    #[inline(always)]
    pub fn is_b00(&self) -> bool {
        *self == Dacbfmd::B00
    }
    #[doc = "One-Time Scan mode"]
    #[inline(always)]
    pub fn is_b10(&self) -> bool {
        *self == Dacbfmd::B10
    }
    #[doc = "FIFO mode"]
    #[inline(always)]
    pub fn is_b11(&self) -> bool {
        *self == Dacbfmd::B11
    }
}
#[doc = "Field `DACBFMD` writer - DAC Buffer Work Mode Select"]
pub type DacbfmdW<'a, REG> = crate::FieldWriter<'a, REG, 2, Dacbfmd>;
impl<'a, REG> DacbfmdW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "Normal mode"]
    #[inline(always)]
    pub fn b00(self) -> &'a mut crate::W<REG> {
        self.variant(Dacbfmd::B00)
    }
    #[doc = "One-Time Scan mode"]
    #[inline(always)]
    pub fn b10(self) -> &'a mut crate::W<REG> {
        self.variant(Dacbfmd::B10)
    }
    #[doc = "FIFO mode"]
    #[inline(always)]
    pub fn b11(self) -> &'a mut crate::W<REG> {
        self.variant(Dacbfmd::B11)
    }
}
#[doc = "DMA Enable Select\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Dmaen {
    #[doc = "0: DMA is disabled."]
    B0 = 0,
    #[doc = "1: DMA is enabled. When DMA is enabled, the DMA request will be generated by original interrupts. The interrupts will not be presented on this module at the same time."]
    B1 = 1,
}
impl From<Dmaen> for bool {
    #[inline(always)]
    fn from(variant: Dmaen) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `DMAEN` reader - DMA Enable Select"]
pub type DmaenR = crate::BitReader<Dmaen>;
impl DmaenR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Dmaen {
        match self.bits {
            false => Dmaen::B0,
            true => Dmaen::B1,
        }
    }
    #[doc = "DMA is disabled."]
    #[inline(always)]
    pub fn is_b0(&self) -> bool {
        *self == Dmaen::B0
    }
    #[doc = "DMA is enabled. When DMA is enabled, the DMA request will be generated by original interrupts. The interrupts will not be presented on this module at the same time."]
    #[inline(always)]
    pub fn is_b1(&self) -> bool {
        *self == Dmaen::B1
    }
}
#[doc = "Field `DMAEN` writer - DMA Enable Select"]
pub type DmaenW<'a, REG> = crate::BitWriter<'a, REG, Dmaen>;
impl<'a, REG> DmaenW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "DMA is disabled."]
    #[inline(always)]
    pub fn b0(self) -> &'a mut crate::W<REG> {
        self.variant(Dmaen::B0)
    }
    #[doc = "DMA is enabled. When DMA is enabled, the DMA request will be generated by original interrupts. The interrupts will not be presented on this module at the same time."]
    #[inline(always)]
    pub fn b1(self) -> &'a mut crate::W<REG> {
        self.variant(Dmaen::B1)
    }
}
impl R {
    #[doc = "Bit 0 - DAC Buffer Enable"]
    #[inline(always)]
    pub fn dacbfen(&self) -> DacbfenR {
        DacbfenR::new((self.bits & 1) != 0)
    }
    #[doc = "Bits 1:2 - DAC Buffer Work Mode Select"]
    #[inline(always)]
    pub fn dacbfmd(&self) -> DacbfmdR {
        DacbfmdR::new((self.bits >> 1) & 3)
    }
    #[doc = "Bit 7 - DMA Enable Select"]
    #[inline(always)]
    pub fn dmaen(&self) -> DmaenR {
        DmaenR::new(((self.bits >> 7) & 1) != 0)
    }
}
impl W {
    #[doc = "Bit 0 - DAC Buffer Enable"]
    #[inline(always)]
    #[must_use]
    pub fn dacbfen(&mut self) -> DacbfenW<C1Spec> {
        DacbfenW::new(self, 0)
    }
    #[doc = "Bits 1:2 - DAC Buffer Work Mode Select"]
    #[inline(always)]
    #[must_use]
    pub fn dacbfmd(&mut self) -> DacbfmdW<C1Spec> {
        DacbfmdW::new(self, 1)
    }
    #[doc = "Bit 7 - DMA Enable Select"]
    #[inline(always)]
    #[must_use]
    pub fn dmaen(&mut self) -> DmaenW<C1Spec> {
        DmaenW::new(self, 7)
    }
}
#[doc = "DAC Control Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`c1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`c1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct C1Spec;
impl crate::RegisterSpec for C1Spec {
    type Ux = u8;
}
#[doc = "`read()` method returns [`c1::R`](R) reader structure"]
impl crate::Readable for C1Spec {}
#[doc = "`write(|w| ..)` method takes [`c1::W`](W) writer structure"]
impl crate::Writable for C1Spec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u8 = 0;
}
#[doc = "`reset()` method sets C1 to value 0"]
impl crate::Resettable for C1Spec {
    const RESET_VALUE: u8 = 0;
}
